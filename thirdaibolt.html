<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>thirdai.bolt &mdash; thirdai  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=5929fcd5"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="thirdai.logging" href="thirdailog.html" />
    <link rel="prev" title="thirdai.neural_db" href="thirdaineuraldb.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            thirdai
              <img src="_static/thirdai_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="thirdaibase.html">thirdai</a></li>
<li class="toctree-l1"><a class="reference internal" href="thirdaineuraldb.html">thirdai.neural_db</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">thirdai.bolt</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#udt">UDT</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.__init__"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.__init__()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.train"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.train()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.cold_start"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.cold_start()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.train_batch"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.train_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.evaluate"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.evaluate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.predict"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.predict()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.predict_batch"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.predict_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.explain"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.explain()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.save"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.save()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.checkpoint"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.checkpoint()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.load"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.load()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.embedding_representation"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.embedding_representation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.get_entity_embedding"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.get_entity_embedding()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.class_name"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.class_name()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.index"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.index()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.index_batch"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.index_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.reset_temporal_trackers"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.reset_temporal_trackers()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.index_nodes"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.index_nodes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.UniversalDeepTransformer.clear_graph"><code class="docutils literal notranslate"><span class="pre">UniversalDeepTransformer.clear_graph()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.Validation"><code class="docutils literal notranslate"><span class="pre">Validation</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.Validation.__init__"><code class="docutils literal notranslate"><span class="pre">Validation.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.Validation.filename"><code class="docutils literal notranslate"><span class="pre">Validation.filename</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.Validation.metrics"><code class="docutils literal notranslate"><span class="pre">Validation.metrics</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.Validation.sparse_validation"><code class="docutils literal notranslate"><span class="pre">Validation.sparse_validation</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.Validation.steps_per_validation"><code class="docutils literal notranslate"><span class="pre">Validation.steps_per_validation</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-thirdai.bolt.types">UDT Input Column Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.types.ColumnType"><code class="docutils literal notranslate"><span class="pre">ColumnType</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.types.categorical"><code class="docutils literal notranslate"><span class="pre">categorical</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.types.categorical.__init__"><code class="docutils literal notranslate"><span class="pre">categorical.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.types.categorical.delimiter"><code class="docutils literal notranslate"><span class="pre">categorical.delimiter</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.types.date"><code class="docutils literal notranslate"><span class="pre">date</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.types.date.__init__"><code class="docutils literal notranslate"><span class="pre">date.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.types.metadata"><code class="docutils literal notranslate"><span class="pre">metadata</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.types.metadata.__init__"><code class="docutils literal notranslate"><span class="pre">metadata.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.types.neighbors"><code class="docutils literal notranslate"><span class="pre">neighbors</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.types.neighbors.__init__"><code class="docutils literal notranslate"><span class="pre">neighbors.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.types.node_id"><code class="docutils literal notranslate"><span class="pre">node_id</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.types.node_id.__init__"><code class="docutils literal notranslate"><span class="pre">node_id.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.types.numerical"><code class="docutils literal notranslate"><span class="pre">numerical</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.types.numerical.__init__"><code class="docutils literal notranslate"><span class="pre">numerical.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.types.sequence"><code class="docutils literal notranslate"><span class="pre">sequence</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.types.sequence.__init__"><code class="docutils literal notranslate"><span class="pre">sequence.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.types.text"><code class="docutils literal notranslate"><span class="pre">text</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thirdai.bolt.types.text.__init__"><code class="docutils literal notranslate"><span class="pre">text.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-thirdai.bolt.temporal">UDT Temporal Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.temporal.TemporalConfig"><code class="docutils literal notranslate"><span class="pre">TemporalConfig</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.temporal.categorical"><code class="docutils literal notranslate"><span class="pre">categorical()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#thirdai.bolt.temporal.numerical"><code class="docutils literal notranslate"><span class="pre">numerical()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="thirdailog.html">thirdai.logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="thirdailicensing.html">thirdai.licensing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">thirdai</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">thirdai.bolt</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/thirdaibolt.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="thirdai-bolt">
<h1>thirdai.bolt<a class="headerlink" href="#thirdai-bolt" title="Link to this heading"></a></h1>
<section id="udt">
<h2>UDT<a class="headerlink" href="#udt" title="Link to this heading"></a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.__init__">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: thirdai._thirdai.bolt.UniversalDeepTransformer, data_types: Dict[str, thirdai::automl::DataType], temporal_tracking_relationships: Dict[str, List[Union[str, thirdai::automl::TemporalConfig]]] = {}, target: str, n_target_classes: Optional[int] = None, integer_target: bool = False, time_granularity: str = ‘daily’, lookahead: int = 0, delimiter: str = ‘,’, model_config: Optional[str] = None, options: dict = {}) -&gt; None</p></li>
</ol>
<p>UniversalDeepTransformer (UDT) Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_types</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#thirdai.bolt.types.ColumnType" title="thirdai.bolt.types.ColumnType"><em>bolt.types.ColumnType</em></a><em>]</em>) – <p>A mapping from column name to column type.
This map specifies the columns that we want to pass into the model; it does
not need to include all columns in the dataset.</p>
<p>Column type is one of:
- <cite>bolt.types.categorical</cite>
- <cite>bolt.types.numerical</cite>
- <cite>bolt.types.text</cite>
- <cite>bolt.types.date</cite>
See bolt.types for details.</p>
<p>If <cite>temporal_tracking_relationships</cite> is non-empty, there must one and only one
bolt.types.date() column. This column contains date strings in YYYY-MM-DD format.</p>
</p></li>
<li><p><strong>temporal_tracking_relationships</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>List</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#thirdai.bolt.temporal.TemporalConfig" title="thirdai.bolt.temporal.TemporalConfig"><em>bolt.temporal.TemporalConfig</em></a><em>]</em><em>]</em><em>]</em>) – <p>Optional.
A mapping from column name to a list of either other column names or bolt.temporal objects.
This mapping tells UDT what columns can be tracked over time for each key.
For example, we may want to tell UDT that we want to track a user’s watch
history by passing in a map like <cite>{“user_id”: [“movie_id”]}</cite></p>
<p>If we provide a mapping from a string to a list of strings like the above,
the temporal tracking configuration will be autotuned. You can achieve finer
grained control by passing in bolt.temporal objects intead of strings.</p>
<p>A bolt.temporal object is one of:
- <cite>bolt.temporal.categorical</cite>
- <cite>bolt.temporal.numerical</cite>
See bolt.temporal for details.</p>
</p></li>
<li><p><strong>target</strong> (<em>str</em>) – Name of the column that contains the value to be predicted by
UDT. The target column has to be a categorical column.</p></li>
<li><p><strong>n_target_classes</strong> (<em>int</em>) – Number of target classes.</p></li>
<li><p><strong>integer_target</strong> (<em>bool</em>) – Whether the target classes are integers in the range 0 to n_target_classes - 1.</p></li>
<li><p><strong>time_granularity</strong> (<em>str</em>) – Optional. Either <cite>“daily”</cite>/<cite>”d”</cite>, <cite>“weekly”</cite>/<cite>”w”</cite>, <cite>“biweekly”</cite>/<cite>”b”</cite>,
or <cite>“monthly”</cite>/<cite>”m”</cite>. Interval of time that UDT should use for temporal features. Temporal numerical
features are clubbed according to this time granularity. E.g. if
<cite>time_granularity=”w”</cite> and the numerical values on days 1 and 2 are
345.25 and 201.1 respectively, then UDT captures a single numerical
value of 546.26 for the week instead of individual values for the two days.
Defaults to “daily”.</p></li>
<li><p><strong>lookahead</strong> (<em>str</em>) – Optional. How far into the future the model should predict. This length of
time is in terms of time_granularity. E.g. ‘time_granularity=”daily”` and
<cite>lookahead=5</cite> means that the model should learn to predict 5 days into the future. Defaults to 0
(predict the current value of the target).</p></li>
<li><p><strong>delimiter</strong> (<em>str</em>) – Optional. Defaults to ‘,’. A single character
(length-1 string) that separates the columns of the CSV training / validation dataset.</p></li>
<li><p><strong>model_config</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – This overwrites the autotuned model with a custom model
defined by the given config file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose each row of our data has the following columns: &quot;product_id&quot;, &quot;timestamp&quot;, &quot;ad_spend&quot;, &quot;sales_quantity&quot;, &quot;sales_performance&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We want to predict next week&#39;s sales performance for each product using temporal context.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># For each product ID, we would like to track both their ad spend and sales quantity over time.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types={</span>
<span class="go">            &quot;product_id&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;timestamp&quot;: bolt.types.date(),</span>
<span class="go">            &quot;ad_spend&quot;: bolt.types.numerical(range=(0, 10000)),</span>
<span class="go">            &quot;sales_quantity&quot;: bolt.types.numerical(range=(0, 20)),</span>
<span class="go">            &quot;sales_performance&quot;: bolt.types.categorical(),</span>
<span class="go">        },</span>
<span class="go">        temporal_tracking_relationships={</span>
<span class="go">            &quot;product_id&quot;: [</span>
<span class="go">                # We can use multiple bolt.temporal objects with the same column name but</span>
<span class="go">                # different history lengths to track different intervals of the same variable</span>
<span class="go">                # Track last 5 weeks of ad spend</span>
<span class="go">                bolt.temporal.numerical(column_name=&quot;ad_spend&quot;, history_length=5),</span>
<span class="go">                # Track last 10 weeks of ad spend</span>
<span class="go">                bolt.temporal.numerical(column_name=&quot;ad_spend&quot;, history_length=10),</span>
<span class="go">                # Track last 5 weeks of sales performance</span>
<span class="go">                bolt.temporal.categorical(column_name=&quot;sales_performance&quot;, history_length=5),</span>
<span class="go">            ]</span>
<span class="go">        },</span>
<span class="go">        target=&quot;sales_performance&quot;,</span>
<span class="go">        n_target_classes=5,</span>
<span class="go">        time_granularity=&quot;weekly&quot;,</span>
<span class="go">        lookahead=2 # predict 2 weeks ahead</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Alternatively suppose our data has the following columns: &quot;user_id&quot;, &quot;movie_id&quot;, &quot;hours_watched&quot;, &quot;timestamp&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We want to build a movie recommendation system.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Then we may configure UDT as follows:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types={</span>
<span class="go">            &quot;user_id&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;timestamp&quot;: bolt.types.date(),</span>
<span class="go">            &quot;movie_id&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;hours_watched&quot;: bolt.types.numerical(range=(0, 25)),</span>
<span class="go">        },</span>
<span class="go">        temporal_tracking_relationships={</span>
<span class="go">            &quot;user_id&quot;: [</span>
<span class="go">                &quot;movie_id&quot;, # autotuned movie temporal tracking</span>
<span class="go">                bolt.temporal.numerical(column_name=&quot;hours_watched&quot;, history_length=&quot;5&quot;) # track last 5 days of hours watched.</span>
<span class="go">            ]</span>
<span class="go">        },</span>
<span class="go">        target=&quot;movie_id&quot;,</span>
<span class="go">        n_target_classes=3000</span>
<span class="go">    )</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Refer to the documentation bolt.types.ColumnType and bolt.temporal.TemporalConfig to better understand column types
and temporal tracking configurations.</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>__init__(self: thirdai._thirdai.bolt.UniversalDeepTransformer, source_column: str, target_column: str, dataset_size: str, use_spell_checker: bool = False, delimiter: str = ‘,’, model_config: Optional[str] = None, options: dict = {}) -&gt; None</p></li>
</ol>
<p>UniversalDeepTransformer (UDT) Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_column</strong> (<em>str</em>) – Optional. Column name specifying the source queries in the input
dataset. If provided then the model can use these queries to augment its training.
If not provided then the model be trained from the target queries directly. If the
source column is specified the the model can be trained with in both a supervised
setting where (incorrect query, correct query) pairs are provided and in an
unsupervised setting where only correct queries are provided. If source is not specified
then it can only be trained in an unsupervised setting.</p></li>
<li><p><strong>target_column</strong> (<em>str</em>) – Column name specifying the target queries in the input dataset.
Queries in this column are the target that the UDT model learns to predict.</p></li>
<li><p><strong>dataset_size</strong> (<em>str</em>) – <p>The size of the input dataset. This size factor informs what
UDT model to create.</p>
<p>The dataset size can be one of the following:
- small
- medium
- large</p>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose we have an input CSV dataset consisting of grammatically or syntactically</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># incorrect queries that we want to reformulate. We will assume that the dataset also</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># has a target correct query for each incorrect query. We can initialize a UDT model</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># for query reformulation as follows:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        target_column=&quot;queries_for_prediction&quot;,</span>
<span class="go">        source_column=&quot;incorrect_queries&quot;,</span>
<span class="go">        dataset_size=&quot;medium&quot;</span>
<span class="go">    )</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>__init__(self: thirdai._thirdai.bolt.UniversalDeepTransformer, target_column: str, dataset_size: str, use_spell_checker: bool = False, delimiter: str = ‘,’, model_config: Optional[str] = None, options: dict = {}) -&gt; None</p></li>
</ol>
<p>UniversalDeepTransformer (UDT) Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_column</strong> (<em>str</em>) – Optional. Column name specifying the source queries in the input
dataset. If provided then the model can use these queries to augment its training.
If not provided then the model be trained from the target queries directly. If the
source column is specified the the model can be trained with in both a supervised
setting where (incorrect query, correct query) pairs are provided and in an
unsupervised setting where only correct queries are provided. If source is not specified
then it can only be trained in an unsupervised setting.</p></li>
<li><p><strong>target_column</strong> (<em>str</em>) – Column name specifying the target queries in the input dataset.
Queries in this column are the target that the UDT model learns to predict.</p></li>
<li><p><strong>dataset_size</strong> (<em>str</em>) – <p>The size of the input dataset. This size factor informs what
UDT model to create.</p>
<p>The dataset size can be one of the following:
- small
- medium
- large</p>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose we have an input CSV dataset consisting of grammatically or syntactically</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># incorrect queries that we want to reformulate. We will assume that the dataset also</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># has a target correct query for each incorrect query. We can initialize a UDT model</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># for query reformulation as follows:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        target_column=&quot;queries_for_prediction&quot;,</span>
<span class="go">        source_column=&quot;incorrect_queries&quot;,</span>
<span class="go">        dataset_size=&quot;medium&quot;</span>
<span class="go">    )</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>__init__(self: thirdai._thirdai.bolt.UniversalDeepTransformer, file_format: str, n_target_classes: int, input_dim: int, model_config: Optional[str] = None, options: dict = {}) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.train">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epochs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#thirdai.bolt.Validation" title="thirdai.bolt.Validation"><span class="pre">Validation</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_in_memory_batches</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Callback</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metrics</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logging_interval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shuffle_reservoir_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">64000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.train" title="Link to this definition"></a></dt>
<dd><p>Trains a UniversalDeepTransformer (UDT) on a given dataset using a file on disk
or in a cloud storage bucket, such as s3 or google cloud storage (GCS). If the
file is on S3, it should be in the normal s3 form, i.e. s3://bucket/path/to/key.
For files in GCS, the path should have the form gcs://bucket/path/to/filename.
We currently support csv and parquet format files. If the file is parquet, it
should end in .parquet or .pqt. Otherwise, we will assume it is a csv file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – Path to the dataset file. It Can be a path to a file on
disk or an S3 or GCS resource identifier. If the file is on s3 or GCS,
regular credentials files will be required for authentication.</p></li>
<li><p><strong>learning_rate</strong> (<em>float</em>) – Optional, uses default if not provided.</p></li>
<li><p><strong>epochs</strong> (<em>int</em>) – Optional, uses default if not provided.</p></li>
<li><p><strong>validation</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#thirdai.bolt.Validation" title="thirdai.bolt.Validation"><em>bolt.Validation</em></a><em>]</em>) – This is an optional parameter that
specifies a validation dataset, metrics, and interval to use during
training.</p></li>
<li><p><strong>batch_size</strong> (<em>Option</em><em>[</em><em>int</em><em>]</em>) – This is an optional parameter indicating which batch
size to use for training. If not specified, the batch size will be autotuned.</p></li>
<li><p><strong>max_in_memory_batches</strong> (<em>Option</em><em>[</em><em>int</em><em>]</em>) – The maximum number of batches to load in
memory at a given time. If this is specified then the dataset will be processed
in a streaming fashion.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – Optional, defaults to True. Controls if additional information
is printed during training.</p></li>
<li><p><strong>callbacks</strong> (<em>List</em><em>[</em><em>bolt.train.callbacks.Callback</em><em>]</em>) – List of callbacks to use during
training.</p></li>
<li><p><strong>metrics</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – List of metrics to compute during training. These are
logged if logging is enabled, and are accessible by any callbacks.</p></li>
<li><p><strong>logging_interval</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – How frequently to log training metrics,
represents the number of batches between logging metrics. If not specified
logging is done at the end of each epoch.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The train method returns a dictionary providing the values of any metrics
computed during training. The format is: {“name of metric”: [list of values]}.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(Dict[str, List[float]])</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span>
<span class="go">        filename=&quot;./train_file&quot;, epochs=5, learning_rate=0.01, max_in_memory_batches=12</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span>
<span class="go">        filename=&quot;s3://bucket/path/to/key&quot;</span>
<span class="go">    )</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If temporal tracking relationships are provided, UDT can make better
predictions by taking temporal context into account. For example, UDT may
keep track of the last few movies that a user has watched to better
recommend the next movie. <cite>model.train()</cite> automatically updates UDT’s
temporal context.</p></li>
<li><p>If the prediction task is binary classification then the model will attempt
to find an optimal threshold for predictions that will be used if <cite>return_predicted_class=True</cite>
is passed to calls to evaluate, predict, and predict_batch. The optimal threshold
will be selected based on what threshold maximizes the first validation metric
on the validation data. If no validation data or metrics are passed in then
it will use the first 100 batches of the training data and the first training
metric. If there is also no training metrics then it will not choose a prediction
threshold.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.cold_start">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">cold_start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filename:</span> <span class="pre">str,</span> <span class="pre">strong_column_names:</span> <span class="pre">~typing.List[str],</span> <span class="pre">weak_column_names:</span> <span class="pre">~typing.List[str],</span> <span class="pre">variable_length:</span> <span class="pre">~data.transformations.VariableLengthConfig</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">&lt;data.transformations.VariableLengthConfig</span> <span class="pre">object&gt;,</span> <span class="pre">learning_rate:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.001,</span> <span class="pre">epochs:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">5,</span> <span class="pre">batch_size:</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">metrics:</span> <span class="pre">~typing.List[str]</span> <span class="pre">=</span> <span class="pre">[],</span> <span class="pre">validation:</span> <span class="pre">~bolt.Validation</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">callbacks:</span> <span class="pre">~typing.List[~bolt.train.callbacks.Callback]</span> <span class="pre">=</span> <span class="pre">[],</span> <span class="pre">max_in_memory_batches:</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">verbose:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True,</span> <span class="pre">logging_interval:</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">comm=None,</span> <span class="pre">shuffle_reservoir_size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">64000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.cold_start" title="Link to this definition"></a></dt>
<dd><p>This method will perform cold start pretraining for UDT. This is a type of
pretraining for text classification models that is especially useful for query
to product recommendation models. It requires that the model takes in a single
text input and has a categorical/multi-categorical output.</p>
<p>The cold start pretraining typically takes in an unsupervised dataset of objects
where each object corresponds to one or more columns of textual metadata. This could
be something like a product catalog (with product ids as objects, and titles,
descriptions, and tags as metadata). The goal with cold start is to pre-train UDT
on unsupervised data so in the future it may be able to answer text search queries
and return the relevant objects. The dataset it takes in should be a csv file that
gives a class id column and some number of text columns, where for a given row
the text is related to the class also specified by that row.</p>
<p>You may cold_start the model and train with supervised data afterwards, typically
leading to faster convergence on the supervised data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – Path to the dataset used for pretraining.</p></li>
<li><p><strong>strong_column_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – The strong column names indicate which
text columns are most closely related to the output class. In this
case closely related means that all of the words in the text are useful
in identifying the output class in that row. For example in the
case of a product catalog then a strong column could be the full title
of the product.</p></li>
<li><p><strong>weak_column_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – The weak column names indicate which text
columns are either more loosely related to the output class. In
this case loosely related means that parts of the text are useful in
identifying the output class, but there may also be parts of the
text that contain more generic words or phrases that don’t have as high
of a correlation. For example in a product catalog the description of
the product could be a weak column because while there is a correlation,
parts of the description may be fairly similar between products or be
too general to completly identify which products the correspond to.</p></li>
<li><p><strong>learning_rate</strong> (<em>float</em>) – Optional, uses default if not provided.</p></li>
<li><p><strong>epochs</strong> (<em>int</em>) – Optional, uses default if not provided.</p></li>
<li><p><strong>batch_size</strong> (<em>Option</em><em>[</em><em>int</em><em>]</em>) – This is an optional parameter indicating which batch
size to use for training. If not specified, the batch size will be autotuned.</p></li>
<li><p><strong>metrics</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – List of metrics to compute during training. These are
logged if logging is enabled, and are accessible by any callbacks.</p></li>
<li><p><strong>validation</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#thirdai.bolt.Validation" title="thirdai.bolt.Validation"><em>bolt.Validation</em></a><em>]</em>) – This is an optional parameter that
specifies a validation dataset, metrics, and interval to use during
training.</p></li>
<li><p><strong>callbacks</strong> (<em>List</em><em>[</em><em>bolt.train.callbacks.Callback</em><em>]</em>) – List of callbacks to use during
training.</p></li>
<li><p><strong>max_in_memory_batches</strong> (<em>Option</em><em>[</em><em>int</em><em>]</em>) – The maximum number of batches to load in
memory at a given time. If this is specified then the dataset will be processed
in a streaming fashion.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – Optional, defaults to True. Controls if additional information
is printed during training.</p></li>
<li><p><strong>logging_interval</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – How frequently to log training metrics,
represents the number of batches between logging metrics. If not specified
logging is done at the end of each epoch.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The train method returns a dictionary providing the values of any metrics
computed during training. The format is: {“name of metric”: [list of values]}.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(Dict[str, List[float]])</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types={</span>
<span class="go">            &quot;query&quot;: bolt.types.text(),</span>
<span class="go">            &quot;product&quot;: bolt.types.categorical(),</span>
<span class="go">        }</span>
<span class="go">        target=&quot;product&quot;,</span>
<span class="go">        n_target_classes=1000,</span>
<span class="go">        integer_target=True,</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">cold_start</span><span class="p">(</span>
<span class="go">        filename=&quot;product_catalog.csv&quot;,</span>
<span class="go">        strong_column_names=[&quot;title&quot;],</span>
<span class="go">        weak_column_names=[&quot;description&quot;, &quot;bullet_points&quot;],</span>
<span class="go">        learning_rate=0.001,</span>
<span class="go">        epochs=5,</span>
<span class="go">        metrics=[&quot;f_measure(0.95)&quot;]</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span>
<span class="go">        train_filename=supervised_query_product_data,</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">({</span><span class="s2">&quot;QUERY&quot;</span><span class="p">:</span> <span class="n">query</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.train_batch">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">train_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.train_batch" title="Link to this definition"></a></dt>
<dd><p>Trains the model on the given training batch.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> (<em>List</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – The raw data comprising the training batch. This should
be in the form {“column_name”: “column_value”} for each column the model expects.</p></li>
<li><p><strong>learning_rate</strong> (<em>float</em>) – Optional, uses default if not provided.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.evaluate">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metrics</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_sparse_inference</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.evaluate" title="Link to this definition"></a></dt>
<dd><p>Evaluates the UniversalDeepTransformer (UDT) on the given dataset and returns a
numpy array of the activations. We currently support csv and parquet format
files. If the file is parquet, it should end in .parquet or .pqt. Otherwise,
we will assume it is a csv file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – Path to the dataset file. Like train, this can be a path
to a local file or a path to a file that lives in an s3 or google cloud
storage (GCS) bucket.</p></li>
<li><p><strong>metrics</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – List of metrics to compute during evaluation.</p></li>
<li><p><strong>use_sparse_inference</strong> (<em>bool</em>) – Optional, defaults to False, determines if
sparse inference is used during evaluation.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – Optional, defaults to True. Controls if additional information
is printed during training.</p></li>
<li><p><strong>top_k</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – Optional, defaults to None. This parameter is only used
for query reformulation model to deterimine how many candidates to select
before computing evaluation metrics.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns a list of values for the specified metrics, keyed by the metric names.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(Dict[str, float])</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;./test_file&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;categorical_accuracy&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If temporal tracking relationships are provided, UDT can make better predictions
by taking temporal context into account. For example, UDT may keep track of
the last few movies that a user has watched to better recommend the next movie.
<cite>model.evaluate()</cite> automatically updates UDT’s temporal context.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.predict">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse_inference</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_predicted_class</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.predict" title="Link to this definition"></a></dt>
<dd><p>Performs inference on a single sample.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_sample</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em>) – The input sample as a dictionary
where the keys are column names and the values are the respective column values.</p></li>
<li><p><strong>use_sparse_inference</strong> (<em>bool</em>) – Whether or not to use sparse inference.</p></li>
<li><p><strong>return_predicted_class</strong> (<em>bool</em>) – If true then the model will return the id of the
predicted class instead of the activations of the output layer. This argument is only
applicable to classification models.</p></li>
<li><p><strong>top_k</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – If specified then the model will return the ids of the
top k predicted classes instead of the activations of the output layer. This argument
is only applicable to classification models.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns a numpy array of the activations if the output is dense, or a tuple
of the active neurons and activations if the output is sparse. The shape of
each array will be (num_nonzeros_in_output, ). If return predicted class is specified
then the class id (an integer) will be returned. If top_k is specified then a list of
integer class ids will be returned. You can map neuron ids back to target class names
by calling the <cite>class_name()</cite> method. If the target column is a sequence, UDT will
perform inference recursively and return a sequence in the same format as the target
column.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(np.ndarray, Tuple[np.ndarray, np.ndarray], List[int], or int)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose we configure UDT as follows:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types={</span>
<span class="go">            &quot;user_id&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;timestamp&quot;: bolt.types.date(),</span>
<span class="go">            &quot;special_event&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;movie_title&quot;: bolt.types.categorical()</span>
<span class="go">        },</span>
<span class="go">        temporal_tracking_relationships={</span>
<span class="go">            &quot;user_id&quot;: [&quot;movie_title&quot;]</span>
<span class="go">        },</span>
<span class="go">        target=&quot;movie_title&quot;,</span>
<span class="go">        n_target_classes=500</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Make a single prediction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">activations</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
<span class="go">        input_sample={&quot;user_id&quot;: &quot;A33225&quot;, &quot;timestamp&quot;: &quot;2022-12-25&quot;, &quot;special_event&quot;: &quot;christmas&quot;}</span>
<span class="go">    )</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The values of columns that are tracked temporally may be unknown during inference
(the column_known_during_inference attribute of the bolt.temporal objects are False
by default). These columns do not need to be passed into <cite>model.predict()</cite>.
For example, we did not pass the “movie_title” column to <cite>model.predict()</cite>.
All other columns must be passed in.</p></li>
<li><p>If temporal tracking relationships are provided, UDT can make better predictions
by taking temporal context into account. For example, UDT may keep track of
the last few movies that a user has watched to better recommend the next movie.
Thus, UDT is at its best when its internal temporal context gets updated with
new true samples. <cite>model.predict()</cite> does not update UDT’s temporal context.
To do this without retraining the model, we need to use <cite>model.index()</cite> or
<cite>model.index_batch()</cite>. Read about <cite>model.index()</cite> and <cite>model.index_batch()</cite>
for details.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.predict_batch">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">predict_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse_inference</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_predicted_class</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.predict_batch" title="Link to this definition"></a></dt>
<dd><p>Performs inference on a batch of samples in parallel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_samples</strong> (<em>List</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – A list of input sample as dictionaries
where the keys are column names as specified in data_types and the
values are the respective column values.</p></li>
<li><p><strong>use_sparse_inference</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether or not to use sparse inference.</p></li>
<li><p><strong>return_predicted_class</strong> (<em>bool</em>) – If true then the model will return the id of the
predicted class instead of the activations of the output layer. This argument is only
applicable to classification models.</p></li>
<li><p><strong>top_k</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – If specified then the model will return the ids of the
top k predicted classes instead of the activations of the output layer. This argument
is only applicable to classification models.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns a numpy array of the activations if the output is dense, or a tuple
of the active neurons and activations if the output is sparse. The shape of
each array will be (batch_size, num_nonzeros_in_output). If return predicted class is specified
then the class id (an integer) will be returned. If top_k is specified then a list of
integer class ids will be returned. You can map neuron ids back to target class names
by calling the <cite>class_name()</cite> method. If the target column is a sequence, UDT will
perform inference recursively and return a sequence in the same format as the target
column.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(np.ndarray, Tuple[np.ndarray, np.ndarray], List[List[int]], or List[int])</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">activations</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_batch</span><span class="p">([</span>
<span class="go">        {&quot;user_id&quot;: &quot;A33225&quot;, &quot;timestamp&quot;: &quot;2022-12-25&quot;, &quot;special_event&quot;: &quot;christmas&quot;},</span>
<span class="go">        {&quot;user_id&quot;: &quot;A25978&quot;, &quot;timestamp&quot;: &quot;2022-12-25&quot;, &quot;special_event&quot;: &quot;christmas&quot;},</span>
<span class="go">        {&quot;user_id&quot;: &quot;A25978&quot;, &quot;timestamp&quot;: &quot;2022-12-26&quot;, &quot;special_event&quot;: &quot;christmas&quot;}&quot;</span>
<span class="go">    ])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The values of columns that are tracked temporally may be unknown during inference
(the column_known_during_inference attribute of the bolt.temporal objects are False
by default). These columns do not need to be passed into <cite>model.predict_batch()</cite>.
For example, we did not pass the “movie_title” column to <cite>model.predict_batch()</cite>.
All other columns must be passed in.</p></li>
<li><p>If temporal tracking relationships are provided, UDT can make better predictions
by taking temporal context into account. For example, UDT may keep track of
the last few movies that a user has watched to better recommend the next movie.
Thus, UDT is at its best when its internal temporal context gets updated with
new true samples. <cite>model.predict_batch()</cite> does not update UDT’s temporal context.
To do this without retraining the model, we need to use <cite>model.index()</cite> or
<cite>model.index_batch()</cite>. Read about <cite>model.index()</cite> and <cite>model.index_batch()</cite>
for details.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.explain">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">explain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_class</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.explain" title="Link to this definition"></a></dt>
<dd><p>Identifies the columns that are most responsible for a predicted outcome
and provides a brief description of the column’s value.</p>
<p>If a target is provided, the model will identify the columns that need
to change for the model to predict the target class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_sample</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em>) – The input sample as a dictionary
where the keys are column names as specified in data_types and the ”
values are the respective column values.</p></li>
<li><p><strong>target_class</strong> (<em>str</em>) – Optional. The desired target class. If provided, the
model will identify the columns that need to change for the model to
predict the target class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of explanations from the input features along with weights representing the
significance of that feature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[Tuple[str, float]]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose we configure UDT as follows:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types={</span>
<span class="go">            &quot;user_id&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;timestamp&quot;: bolt.types.date(),</span>
<span class="go">            &quot;special_event&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;movie_title&quot;: bolt.types.categorical()</span>
<span class="go">        },</span>
<span class="go">        temporal_tracking_relationships={</span>
<span class="go">            &quot;user_id&quot;: &quot;movie_title&quot;</span>
<span class="go">        },</span>
<span class="go">        target=&quot;movie_title&quot;,</span>
<span class="go">        n_target_classes=500,</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Make a single prediction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">explanations</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span>
<span class="go">        input_sample={&quot;user_id&quot;: &quot;A33225&quot;, &quot;timestamp&quot;: &quot;2022-02-02&quot;, &quot;special_event&quot;: &quot;christmas&quot;}, target_class=35</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.save">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.save" title="Link to this definition"></a></dt>
<dd><p>Serializes an instance of UniversalDeepTransformer (UDT) into a file on disk.
The serialized UDT includes its current temporal context. The <cite>save</cite> method just saves
the model parameters, the <cite>checkpoint</cite> method saves additional information such as
the optimizer state to use if training is resumed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – The file on disk to serialize this instance of UDT into.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;udt_savefile.bolt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="s2">&quot;udt_savefile.bolt&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.checkpoint">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">checkpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.checkpoint" title="Link to this definition"></a></dt>
<dd><p>Serializes an instance of UniversalDeepTransformer (UDT) into a file on disk.
The serialized UDT includes its current temporal context. The <cite>save</cite> method just saves
the model parameters, the <cite>checkpoint</cite> method saves additional information such as
the optimizer state to use if training is resumed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – The file on disk to serialize this instance of UDT into.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;udt_savefile.bolt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="s2">&quot;udt_savefile.bolt&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.load">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bolt.UniversalDeepTransformer</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.load" title="Link to this definition"></a></dt>
<dd><p>Loads a serialized instance of a UniversalDeepTransformer (UDT) model from a
file on disk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – The file on disk from where to load an instance of UDT.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The loaded instance of UDT</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>UniversalDeepTransformer</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;udt_savefile.bolt&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.embedding_representation">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">embedding_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.embedding_representation" title="Link to this definition"></a></dt>
<dd><p>Performs inference on a single sample and returns the penultimate layer of
UniversalDeepTransformer (UDT) so that it can be used as an embedding
representation for downstream applications.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_sample</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em>) – The input sample as a dictionary
where the keys are column names as specified in data_types and the
values are the respective column values.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns a numpy array of the penultimate layer’s activations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose we configure UDT as follows:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types={</span>
<span class="go">            &quot;user_id&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;timestamp&quot;: bolt.types.date(),</span>
<span class="go">            &quot;special_event&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;movie_title&quot;: bolt.types.categorical()</span>
<span class="go">        },</span>
<span class="go">        temporal_tracking_relationships={</span>
<span class="go">            &quot;user_id&quot;: [&quot;movie_title&quot;]</span>
<span class="go">        },</span>
<span class="go">        target=&quot;movie_title&quot;,</span>
<span class="go">        n_target_classes=500,</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get an embedding representation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">embedding</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">embedding_representation</span><span class="p">(</span>
<span class="go">        input_sample={&quot;user_id&quot;: &quot;A33225&quot;, &quot;timestamp&quot;: &quot;2022-12-25&quot;, &quot;special_event&quot;: &quot;christmas&quot;}</span>
<span class="go">    )</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The values of columns that are tracked temporally may be unknown during inference
(the column_known_during_inference attribute of the bolt.temporal objects are False
by default). These columns do not need to be passed into <cite>model.embedding_representation()</cite>.
For example, we did not pass the “movie_title” column to <cite>model.embedding_representation()</cite>.
All other columns must be passed in.</p></li>
<li><p>If temporal tracking relationships are provided, UDT can make better predictions
by taking temporal context into account. For example, UDT may keep track of
the last few movies that a user has watched to better recommend the next movie.
Thus, UDT is at its best when its internal temporal context gets updated with
new true samples. <cite>model.predict()</cite> does not update UDT’s temporal context.
To do this without retraining the model, we need to use <cite>model.index()</cite> or
<cite>model.index_batch()</cite>. Read about <cite>model.index()</cite> and <cite>model.index_batch()</cite>
for details.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.get_entity_embedding">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">get_entity_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.get_entity_embedding" title="Link to this definition"></a></dt>
<dd><p>Returns an embedding representation for a given output entity, an entity being
the name of a class predicted as output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label_id</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>str</em><em>]</em>) – The the name of the entity to get an embedding for.</p></li>
<li><p><strong>integer_target=True</strong> (<em>If</em>) – </p></li>
<li><p><strong>to</strong> (<em>this function should take in an integer from 0</em>) – </p></li>
<li><p><strong>string.</strong> (<em>n_target_classes - 1 instead</em><em> of </em><em>a</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 1D numpy array of floats representing a dense embedding of that entity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.class_name">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">class_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.class_name" title="Link to this definition"></a></dt>
<dd><p>Returns the target class name associated with an output neuron ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>neuron_id</strong> (<em>int</em>) – The index of the neuron in UDT’s output layer. This is
useful for mapping the activations returned by <cite>evaluate()</cite> and
<cite>predict()</cite> back to class names.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The class names that corresponds to the given neuron_id.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">activations</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
<span class="go">        input_sample={&quot;user_id&quot;: &quot;A33225&quot;, &quot;timestamp&quot;: &quot;2022-12-25&quot;, &quot;special_event&quot;: &quot;christmas&quot;}</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">top_recommendation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">activations</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">class_name</span><span class="p">(</span><span class="n">top_recommendation</span><span class="p">)</span>
<span class="go">&quot;Die Hard&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.index">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.index" title="Link to this definition"></a></dt>
<dd><p>Indexes a single true sample to keep UniversalDeepTransformer’s (UDT) temporal
context up to date.</p>
<p>If temporal tracking relationships are provided, UDT can make better predictions
by taking temporal context into account. For example, UDT may keep track of
the last few movies that a user has watched to better recommend the next movie.
Thus, UDT is at its best when its internal temporal context gets updated with
new true samples. <cite>model.index()</cite> does exactly this.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_sample</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em>) – The input sample as a dictionary
where the keys are column names as specified in data_types and the ”
values are the respective column values.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose we configure UDT to do movie recommendation as follows:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types={</span>
<span class="go">            &quot;user_id&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;timestamp&quot;: bolt.types.date(),</span>
<span class="go">            &quot;special_event&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;movie_title&quot;: bolt.types.categorical()</span>
<span class="go">        },</span>
<span class="go">        temporal_tracking_relationships={</span>
<span class="go">            &quot;user_id&quot;: [&quot;movie_title&quot;]</span>
<span class="go">        },</span>
<span class="go">        target=&quot;movie_title&quot;,</span>
<span class="go">        n_target_classes=500,</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We then deploy the model for inference. Inference is performed by calling model.predict()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">activations</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
<span class="go">        input_sample={&quot;user_id&quot;: &quot;A33225&quot;, &quot;timestamp&quot;: &quot;2022-12-25&quot;, &quot;special_event&quot;: &quot;christmas&quot;}</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose we later learn that user &quot;A33225&quot; ends up watching &quot;Die Hard 3&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We can call model.index() to keep UDT&#39;s temporal context up to date.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
<span class="go">        input_sample={&quot;user_id&quot;: &quot;A33225&quot;, &quot;timestamp&quot;: &quot;2022-12-25&quot;, &quot;special_event&quot;: &quot;christmas&quot;, &quot;movie_title&quot;: &quot;Die Hard 3&quot;}</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.index_batch">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">index_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_samples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.index_batch" title="Link to this definition"></a></dt>
<dd><p>Indexes a batch of true samples to keep UniversalDeepTransformer’s (UDT) temporal
context up to date.</p>
<p>If temporal tracking relationships are provided, UDT can make better predictions
by taking temporal context into account. For example, UDT may keep track of
the last few movies that a user has watched to better recommend the next movie.
Thus, UDT is at its best when its internal temporal context gets updated with
new true samples. <cite>model.index_batch()</cite> does exactly this with a batch of samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_samples</strong> (<em>List</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – The input sample as a dictionary
where the keys are column names as specified in data_types and the ”
values are the respective column values.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose we configure UDT to do movie recommendation as follows:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types={</span>
<span class="go">            &quot;user_id&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;timestamp&quot;: bolt.types.date(),</span>
<span class="go">            &quot;special_event&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;movie_title&quot;: bolt.types.categorical()</span>
<span class="go">        },</span>
<span class="go">        temporal_tracking_relationships={</span>
<span class="go">            &quot;user_id&quot;: [&quot;movie_title&quot;]</span>
<span class="go">        },</span>
<span class="go">        target=&quot;movie_title&quot;,</span>
<span class="go">        n_target_classes=500,</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We then deploy the model for inference. Inference is performed by calling model.predict()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">activations</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
<span class="go">        input_sample={&quot;user_id&quot;: &quot;A33225&quot;, &quot;timestamp&quot;: &quot;2022-12-25&quot;, &quot;special_event&quot;: &quot;christmas&quot;}</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose we later learn what users actually watched.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We can call model.index_batch() to keep UDT&#39;s temporal context up to date.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">index_batch</span><span class="p">(</span>
<span class="go">        input_samples=[</span>
<span class="go">            {&quot;user_id&quot;: &quot;A33225&quot;, &quot;timestamp&quot;: &quot;2022-12-25&quot;, &quot;special_event&quot;: &quot;christmas&quot;, &quot;movie_title&quot;: &quot;Die Hard 3&quot;},</span>
<span class="go">            {&quot;user_id&quot;: &quot;A39574&quot;, &quot;timestamp&quot;: &quot;2022-12-25&quot;, &quot;special_event&quot;: &quot;christmas&quot;, &quot;movie_title&quot;: &quot;Home Alone&quot;},</span>
<span class="go">            {&quot;user_id&quot;: &quot;A39574&quot;, &quot;timestamp&quot;: &quot;2022-12-26&quot;, &quot;special_event&quot;: &quot;christmas&quot;, &quot;movie_title&quot;: &quot;Home Alone 2&quot;},</span>
<span class="go">        ]</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.reset_temporal_trackers">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">reset_temporal_trackers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.reset_temporal_trackers" title="Link to this definition"></a></dt>
<dd><p>Resets UniversalDeepTransformer’s (UDT) temporal context. When temporal
relationships are supplied, UDT assumes that we feed it data in chronological
order. Thus, if we break this assumption, we need to first reset the temporal
trackers. An example of when you would use this is when you want to repeat the
UDT training routine on the same dataset. Since you would be training on data
from the same time period as before, we need to first reset the temporal trackers
so that we don’t double count events.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">reset_temporal_trackers</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.index_nodes">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">index_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_source</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dataset.DataSource</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.index_nodes" title="Link to this definition"></a></dt>
<dd><p>Updates the graph that the UDT model is performing graph node classification on. The file
should have the same node id, neighbors, and features columns as the model is configured to accept.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – The filename to load the graph from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.UniversalDeepTransformer.clear_graph">
<span class="sig-prename descclassname"><span class="pre">UniversalDeepTransformer.</span></span><span class="sig-name descname"><span class="pre">clear_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.UniversalDeepTransformer.clear_graph" title="Link to this definition"></a></dt>
<dd><p>Clears all graph info that is being tracked by the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="thirdai.bolt.Validation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">thirdai.bolt.</span></span><span class="sig-name descname"><span class="pre">Validation</span></span><a class="headerlink" href="#thirdai.bolt.Validation" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.Validation.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metrics</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_sparse_inference</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.Validation.__init__" title="Link to this definition"></a></dt>
<dd><p>Creates a validation object that stores the necessary information for the model
to perform validation during training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The name of the validation file.</p></li>
<li><p><strong>metrics</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – The metrics to compute for validation.</p></li>
<li><p><strong>interval</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The interval, in number of batches, between computing
validation. For instance, <cite>interval=10</cite> means that validation metrics will
be computed every 10 batches. If it is not specified then validation will
be done after each epoch.</p></li>
<li><p><strong>use_sparse_inference</strong> (<em>bool</em>) – Optional, defaults to False. When True, sparse
inference will be used during validation.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">validation</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">Validation</span><span class="p">(</span>
<span class="go">        filename=&quot;validation.csv&quot;, metrics=[&quot;categorical_accuracy&quot;], interval=10</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="s2">&quot;train.csv&quot;</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">validation</span><span class="o">=</span><span class="n">validation</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="thirdai.bolt.Validation.filename">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">filename</span></span><a class="headerlink" href="#thirdai.bolt.Validation.filename" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="thirdai.bolt.Validation.metrics">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">metrics</span></span><a class="headerlink" href="#thirdai.bolt.Validation.metrics" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="thirdai.bolt.Validation.sparse_validation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sparse_validation</span></span><a class="headerlink" href="#thirdai.bolt.Validation.sparse_validation" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="thirdai.bolt.Validation.steps_per_validation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">steps_per_validation</span></span><a class="headerlink" href="#thirdai.bolt.Validation.steps_per_validation" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-thirdai.bolt.types">
<span id="udt-input-column-types"></span><h2>UDT Input Column Types<a class="headerlink" href="#module-thirdai.bolt.types" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="thirdai.bolt.types.ColumnType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">thirdai.bolt.types.</span></span><span class="sig-name descname"><span class="pre">ColumnType</span></span><a class="headerlink" href="#thirdai.bolt.types.ColumnType" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Base class for bolt types.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="thirdai.bolt.types.categorical">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">thirdai.bolt.types.</span></span><span class="sig-name descname"><span class="pre">categorical</span></span><a class="headerlink" href="#thirdai.bolt.types.categorical" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#thirdai.bolt.types.ColumnType" title="thirdai._thirdai.bolt.types.ColumnType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnType</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.types.categorical.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metadata</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#thirdai.bolt.types.metadata" title="thirdai.bolt.types.metadata"><span class="pre">bolt.types.metadata</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.types.categorical.__init__" title="Link to this definition"></a></dt>
<dd><p>Temporal categorical config. Use this object to configure how a
categorical column is tracked over time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>column_name</strong> (<em>str</em>) – The name of the tracked column.</p></li>
<li><p><strong>track_last_n</strong> (<em>int</em>) – Number of last categorical values to track
per tracking id.</p></li>
<li><p><strong>column_known_during_inference</strong> (<em>bool</em>) – Optional. Whether the
value of the tracked column is known during inference. Defaults
to False.</p></li>
<li><p><strong>use_metadata</strong> (<em>bool</em>) – Optional. Whether to use the metadata of the N
tracked items, if metadata is provided in the corresponding
categorical column type object. Ignored if no metadata is provided.
Defaults to False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose each row of our data has the following columns: &quot;product_id&quot;, &quot;timestamp&quot;, &quot;ad_spend_level&quot;, &quot;sales_performance&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We want to predict the current week&#39;s sales performance for each product using temporal context.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># For each product ID, we would like to track both their ad spend level and sales performance over time.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Ad spend level is known at the time of inference but sales performance is not. Then we can configure UDT as follows:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types={</span>
<span class="go">            &quot;product_id&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;timestamp&quot;: bolt.types.date(),</span>
<span class="go">            &quot;ad_spend_level&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;sales_performance&quot;: bolt.types.categorical(),</span>
<span class="go">        },</span>
<span class="go">        temporal_tracking_relationships={</span>
<span class="go">            &quot;product_id&quot;: [</span>
<span class="go">                bolt.temporal.categorical(column_name=&quot;ad_spend_level&quot;, track_last_n=5, column_known_during_inference=True),</span>
<span class="go">                bolt.temporal.categorical(column_name=&quot;ad_spend_level&quot;, track_last_n=25, column_known_during_inference=True),</span>
<span class="go">                bolt.temporal.categorical(column_name=&quot;sales_performance&quot;, track_last_n=5), # column_known_during_inference defaults to False</span>
<span class="go">            ]</span>
<span class="go">        },</span>
<span class="go">        ...</span>
<span class="go">    )</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>Temporal categorical features are tracked as a set; if we track the last 5 ad spend levels,</dt><dd><p>we capture what the last 5 ad spend levels are, but we do not capture their order.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The same column can be tracked more than once, allowing us to capture both short and</dt><dd><p>long term trends.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="thirdai.bolt.types.categorical.delimiter">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">delimiter</span></span><a class="headerlink" href="#thirdai.bolt.types.categorical.delimiter" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="thirdai.bolt.types.date">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">thirdai.bolt.types.</span></span><span class="sig-name descname"><span class="pre">date</span></span><a class="headerlink" href="#thirdai.bolt.types.date" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#thirdai.bolt.types.ColumnType" title="thirdai._thirdai.bolt.types.ColumnType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnType</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.types.date.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.types.date.__init__" title="Link to this definition"></a></dt>
<dd><p>Date column type. Use this object if a column contains date strings.
Date strings must be in YYYY-MM-DD format.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types: {</span>
<span class="go">            &quot;timestamp&quot;: bolt.types.date()</span>
<span class="go">        }</span>
<span class="go">        ...</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="thirdai.bolt.types.metadata">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">thirdai.bolt.types.</span></span><span class="sig-name descname"><span class="pre">metadata</span></span><a class="headerlink" href="#thirdai.bolt.types.metadata" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.types.metadata.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_column_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_types</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#thirdai.bolt.types.ColumnType" title="thirdai.bolt.types.ColumnType"><span class="pre">bolt.types.ColumnType</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">','</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.types.metadata.__init__" title="Link to this definition"></a></dt>
<dd><p>A configuration object for processing a metadata file to enrich categorical
features from the main dataset. To illustrate when this is useful, suppose
we are building a movie recommendation system. The contents of the training
dataset may look something like the following:
user_id,movie_id,timestamp
A526,B894,2022-01-01
A339,B801,2022-01-01
A293,B801,2022-01-01
…
If you have additional information about users or movies, such as users’
age groups or movie genres, you can use that information to enrich your
model. Adding these features into the main dataset as new columns is wasteful
because the same users and movies ids will be repeated many times throughout
the dataset. Instead, we can put them all in a metadata file and UDT will
inject these features where appropriate.
:param filename: Path to metadata file. The file should be in CSV format.
:type filename: str
:param key_column_name: The name of the column whose values are used as</p>
<blockquote>
<div><p>keys to map metadata features back to values in the main dataset.
This column does not need to be passed into the <cite>data_types</cite> argument.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_types</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#thirdai.bolt.types.ColumnType" title="thirdai.bolt.types.ColumnType"><em>bolt.types.ColumnType</em></a><em>]</em>) – A mapping from column name
to column type. Column type is one of:
- <cite>bolt.types.categorical</cite>
- <cite>bolt.types.numerical</cite>
- <cite>bolt.types.text</cite>
- <cite>bolt.types.date</cite></p></li>
<li><p><strong>delimiter</strong> (<em>str</em>) – Optional. Defaults to ‘,’. A single character
(length-1 string) that separates the columns of the metadata file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;user_meta.csv&quot;</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<span class="go">user_id,age</span>
<span class="go">A526,52</span>
<span class="go">A531,22</span>
<span class="go">A339,29</span>
<span class="go">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types: {</span>
<span class="go">            &quot;user_id&quot;: bolt.types.categorical(</span>
<span class="go">                delimiter=&#39; &#39;,</span>
<span class="go">                metadata=bolt.types.metadata(</span>
<span class="go">                    filename=&quot;user_meta.csv&quot;,</span>
<span class="go">                    data_types={&quot;age&quot;: bolt.types.numerical()},</span>
<span class="go">                    key_column_name=&quot;user_id&quot;</span>
<span class="go">                )</span>
<span class="go">            )</span>
<span class="go">        }</span>
<span class="go">        ...</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="thirdai.bolt.types.neighbors">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">thirdai.bolt.types.</span></span><span class="sig-name descname"><span class="pre">neighbors</span></span><a class="headerlink" href="#thirdai.bolt.types.neighbors" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#thirdai.bolt.types.ColumnType" title="thirdai._thirdai.bolt.types.ColumnType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnType</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.types.neighbors.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.types.neighbors.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="thirdai.bolt.types.node_id">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">thirdai.bolt.types.</span></span><span class="sig-name descname"><span class="pre">node_id</span></span><a class="headerlink" href="#thirdai.bolt.types.node_id" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#thirdai.bolt.types.ColumnType" title="thirdai._thirdai.bolt.types.ColumnType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnType</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.types.node_id.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.types.node_id.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="thirdai.bolt.types.numerical">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">thirdai.bolt.types.</span></span><span class="sig-name descname"><span class="pre">numerical</span></span><a class="headerlink" href="#thirdai.bolt.types.numerical" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#thirdai.bolt.types.ColumnType" title="thirdai._thirdai.bolt.types.ColumnType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnType</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.types.numerical.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">range</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">granularity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'m'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.types.numerical.__init__" title="Link to this definition"></a></dt>
<dd><p>Numerical column type. Use this object if a column contains numerical
data (the value is treated as a quantity). Examples include hours of
a movie watched, sale quantity, or population size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>range</strong> (<em>tuple</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em>) – The expected range (min to max) of the
numeric quantity. The more accurate this range to the test data, the
better the model performance.</p></li>
<li><p><strong>granularity</strong> (<em>str</em>) – Optional. One of “extrasmall”/”xs”, “small”/”s”, “medium”/”m”,
“large”/”l” or “extralarge”/”xl” . Defaults to “m”.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types: {</span>
<span class="go">            &quot;hours_watched&quot;: bolt.types.numerical(range=(0, 25), granularity=&quot;xs&quot;)</span>
<span class="go">        }</span>
<span class="go">        ...</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="thirdai.bolt.types.sequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">thirdai.bolt.types.</span></span><span class="sig-name descname"><span class="pre">sequence</span></span><a class="headerlink" href="#thirdai.bolt.types.sequence" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#thirdai.bolt.types.ColumnType" title="thirdai._thirdai.bolt.types.ColumnType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnType</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.types.sequence.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#thirdai.bolt.types.sequence.__init__" title="Link to this definition"></a></dt>
<dd><p>Sequence column type. Use this object if a column contains an ordered sequence
of strings delimited by a character. The delimiter must be different than the
delimiter between columns.</p>
<p>When the target column is a sequence type, then UDT will perform inferences
recursively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delimiter</strong> (<em>str</em>) – Optional. The sequence delimiter. Defaults to “ “.</p></li>
<li><p><strong>max_length</strong> (<em>int</em>) – Required if the column is the target. The maximum length
of the sequence. If UDT sees longer sequences, elements beyond the provided
upper bound will be ignored.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types: {</span>
<span class="go">            &quot;input_sequence&quot;: bolt.types.sequence(delimiter=&#39;\t&#39;)</span>
<span class="go">            &quot;output_sequence&quot;: bolt.types.sequence(max_length=30) # max_length must be provided for target sequence.</span>
<span class="go">        },</span>
<span class="go">        target=&quot;output_sequence&quot;,</span>
<span class="go">        n_target_classes=26</span>
<span class="go">        ...</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="thirdai.bolt.types.text">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">thirdai.bolt.types.</span></span><span class="sig-name descname"><span class="pre">text</span></span><a class="headerlink" href="#thirdai.bolt.types.text" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#thirdai.bolt.types.ColumnType" title="thirdai._thirdai.bolt.types.ColumnType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnType</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="thirdai.bolt.types.text.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#thirdai.bolt.types.text.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: thirdai._thirdai.bolt.types.text, tokenizer: str = ‘words’, contextual_encoding: str = ‘none’, lowercase: bool = True) -&gt; None</p></li>
</ol>
<p>Text column type. Use this object if a column contains text data
(the meaning of the text matters). Examples include descriptions,
search queries, and user bios.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tokenizer</strong> (<em>str</em>) – Optional. Either “words”, “words-punct” or
“char-k” (k is a number, e.g. “char-5”). Defaults to “words”.</p></li>
<li><p><strong>contextual_encoding</strong> (<em>str</em>) – Optional. Either “local”, “global”, “ngram-N”, or
“none”, defaults to “none”.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types: {</span>
<span class="go">            &quot;user_motto&quot;: bolt.types.text(),</span>
<span class="go">            &quot;user_bio&quot;: bolt.types.text(contextual_encoding=&quot;local&quot;)</span>
<span class="go">        }</span>
<span class="go">        ...</span>
<span class="go">    )</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: thirdai._thirdai.bolt.types.text, tokenizer: thirdai._thirdai.dataset.WordpieceTokenizer, contextual_encoding: str = ‘none’) -&gt; None</p></li>
</ol>
<p>Text column type. Use this object if a column contains text data
(the meaning of the text matters). Examples include descriptions,
search queries, and user bios.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tokenizer</strong> (<em>str</em>) – Optional. Either “words”, “words-punct” or
“char-k” (k is a number, e.g. “char-5”). Defaults to “words”.</p></li>
<li><p><strong>contextual_encoding</strong> (<em>str</em>) – Optional. Either “local”, “global”, “ngram-N”, or
“none”, defaults to “none”.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types: {</span>
<span class="go">            &quot;user_motto&quot;: bolt.types.text(),</span>
<span class="go">            &quot;user_bio&quot;: bolt.types.text(contextual_encoding=&quot;local&quot;)</span>
<span class="go">        }</span>
<span class="go">        ...</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="module-thirdai.bolt.temporal">
<span id="udt-temporal-options"></span><h2>UDT Temporal Options<a class="headerlink" href="#module-thirdai.bolt.temporal" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="thirdai.bolt.temporal.TemporalConfig">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">thirdai.bolt.temporal.</span></span><span class="sig-name descname"><span class="pre">TemporalConfig</span></span><a class="headerlink" href="#thirdai.bolt.temporal.TemporalConfig" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Base class for temporal feature configs.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="thirdai.bolt.temporal.categorical">
<span class="sig-prename descclassname"><span class="pre">thirdai.bolt.temporal.</span></span><span class="sig-name descname"><span class="pre">categorical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">track_last_n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column_known_during_inference</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_metadata</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#thirdai.bolt.temporal.TemporalConfig" title="thirdai.bolt.temporal.TemporalConfig"><span class="pre">bolt.temporal.TemporalConfig</span></a></span></span><a class="headerlink" href="#thirdai.bolt.temporal.categorical" title="Link to this definition"></a></dt>
<dd><p>Temporal categorical config. Use this object to configure how a
categorical column is tracked over time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>column_name</strong> (<em>str</em>) – The name of the tracked column.</p></li>
<li><p><strong>track_last_n</strong> (<em>int</em>) – Number of last categorical values to track
per tracking id.</p></li>
<li><p><strong>column_known_during_inference</strong> (<em>bool</em>) – Optional. Whether the
value of the tracked column is known during inference. Defaults
to False.</p></li>
<li><p><strong>use_metadata</strong> (<em>bool</em>) – Optional. Whether to use the metadata of the N
tracked items, if metadata is provided in the corresponding
categorical column type object. Ignored if no metadata is provided.
Defaults to False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose each row of our data has the following columns: &quot;product_id&quot;, &quot;timestamp&quot;, &quot;ad_spend_level&quot;, &quot;sales_performance&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We want to predict the current week&#39;s sales performance for each product using temporal context.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># For each product ID, we would like to track both their ad spend level and sales performance over time.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Ad spend level is known at the time of inference but sales performance is not. Then we can configure UDT as follows:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types={</span>
<span class="go">            &quot;product_id&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;timestamp&quot;: bolt.types.date(),</span>
<span class="go">            &quot;ad_spend_level&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;sales_performance&quot;: bolt.types.categorical(),</span>
<span class="go">        },</span>
<span class="go">        temporal_tracking_relationships={</span>
<span class="go">            &quot;product_id&quot;: [</span>
<span class="go">                bolt.temporal.categorical(column_name=&quot;ad_spend_level&quot;, track_last_n=5, column_known_during_inference=True),</span>
<span class="go">                bolt.temporal.categorical(column_name=&quot;ad_spend_level&quot;, track_last_n=25, column_known_during_inference=True),</span>
<span class="go">                bolt.temporal.categorical(column_name=&quot;sales_performance&quot;, track_last_n=5), # column_known_during_inference defaults to False</span>
<span class="go">            ]</span>
<span class="go">        },</span>
<span class="go">        ...</span>
<span class="go">    )</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>Temporal categorical features are tracked as a set; if we track the last 5 ad spend levels,</dt><dd><p>we capture what the last 5 ad spend levels are, but we do not capture their order.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The same column can be tracked more than once, allowing us to capture both short and</dt><dd><p>long term trends.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="thirdai.bolt.temporal.numerical">
<span class="sig-prename descclassname"><span class="pre">thirdai.bolt.temporal.</span></span><span class="sig-name descname"><span class="pre">numerical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column_known_during_inference</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#thirdai.bolt.temporal.TemporalConfig" title="thirdai.bolt.temporal.TemporalConfig"><span class="pre">bolt.temporal.TemporalConfig</span></a></span></span><a class="headerlink" href="#thirdai.bolt.temporal.numerical" title="Link to this definition"></a></dt>
<dd><p>Temporal numerical config. Use this object to configure how a
numerical column is tracked over time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>column_name</strong> (<em>str</em>) – The name of the tracked column.</p></li>
<li><p><strong>history_length</strong> (<em>int</em>) – Amount of time to look back. Time is in terms
of the time granularity passed to the UDT constructor.</p></li>
<li><p><strong>column_known_during_inference</strong> (<em>bool</em>) – Optional. Whether the
value of the tracked column is known during inference. Defaults
to False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Suppose each row of our data has the following columns: &quot;product_id&quot;, &quot;timestamp&quot;, &quot;ad_spend&quot;, &quot;sales_performance&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We want to predict the current week&#39;s sales performance for each product using temporal context.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># For each product ID, we would like to track both their ad spend and sales performance over time.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Ad spend is known at the time of inference but sales performance is not. Then we can configure UDT as follows:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">bolt</span><span class="o">.</span><span class="n">UniversalDeepTransformer</span><span class="p">(</span>
<span class="go">        data_types={</span>
<span class="go">            &quot;product_id&quot;: bolt.types.categorical(),</span>
<span class="go">            &quot;timestamp&quot;: bolt.types.date(),</span>
<span class="go">            &quot;ad_spend&quot;: bolt.types.numerical(range=(0, 10000)),</span>
<span class="go">            &quot;sales_performance&quot;: bolt.types.categorical(),</span>
<span class="go">        },</span>
<span class="go">        target=&quot;sales_performance&quot;</span>
<span class="go">        time_granularity=&quot;weekly&quot;,</span>
<span class="go">        temporal_tracking_relationships={</span>
<span class="go">            &quot;product_id&quot;: [</span>
<span class="go">                # Track last 5 weeks of ad spend</span>
<span class="go">                bolt.temporal.numerical(column_name=&quot;ad_spend&quot;, history_length=5, column_known_during_inference=True),</span>
<span class="go">                # Track last 10 weeks of ad spend</span>
<span class="go">                bolt.temporal.numerical(column_name=&quot;ad_spend&quot;, history_length=10, column_known_during_inference=True),</span>
<span class="go">                # Track last 5 weeks of sales quantity</span>
<span class="go">                bolt.temporal.numerical(column_name=&quot;sales_quantity&quot;, history_length=5), # column_known_during_inference defaults to False</span>
<span class="go">            ]</span>
<span class="go">        },</span>
</pre></div>
</div>
<blockquote>
<div><p>)</p>
</div></blockquote>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>The same column can be tracked more than once, allowing us to capture both short and</dt><dd><p>long term trends.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="thirdaineuraldb.html" class="btn btn-neutral float-left" title="thirdai.neural_db" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="thirdailog.html" class="btn btn-neutral float-right" title="thirdai.logging" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, t.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>